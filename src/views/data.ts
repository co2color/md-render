export const mdobj = {
  "title": "实现@vue/reactivity的effect函数",
  "top_flag": 0,
  "create_time": "1676999349",
  "article_summary": "vue3响应式核心",
  "id": 84,
  "content": "> 如果你已经熟练掌握[vue3 effect](https://github.com/vuejs/core/blob/HEAD/packages/reactivity/src/index.ts)的实现，那请不要再继续浪费1秒钟阅读本文章，大神请绕道。\n阅读本篇文章，你至少需要具备中级JS水平，并了解Vue3 composition Api以及ES6 Proxy的使用，最好还能再了解一点订阅发布这种设计模式。\n本篇文章仅对effect给出简约实现，去除了实际工程中的很多边界情况。但effect必须配合reactive/ref使用，因此会顺便给出这二者的基本响应式实现。\n\n\n首先来个最终用法：\n``` js\n// reactive和effect都是从该库引入\nconst user = reactive({ age: 19 })\n// 我们规定effect的cb会先执行\n// (不要问为什么会先执行。。你当然也可以写一个自己的effect规定先不执行，触发依赖后再首次执行，这都无所谓，不是重点)\neffect(() => {\n  console.log(user.age, 'user.age')\n})\nuser.age = 20\n```\n首先定义响应式数据user，然后执行effect这个函数，该函数传入一个函数(后面简称函数cb，注意这是callback的简写哈。。)作为参数。接着执行age的赋值。\n我们都知道vue3中reactive的数据具有响应性，也就是说当你执行`user.age = 20`时，就会触发响应，重新执行cb()。\n那么一步步来，我们先不关注reactive，只看effect，当你执行effect()这个函数时，发生了什么？\n1. 创建effect函数；\n2. effect函数里面new了一个Effect；\n3. new完后，cb会执行一次；\n4. cb执行过程中，收集cb函数语句的依赖，这里发现收集到了user.age这个依赖（人话：后续user.age改变时，用某种方式让cb再次执行）\n\n#### 1~2：创建effect函数，创建reactiveEffect类，然后new reactiveEffect：\n``` js\nclass reactiveEffect {\n  deps = [] // 收集依赖到该数组，因为依赖不一定只有一个(上面代码就user.age一个，因此这种情况deps.length = 1)\n  constructor(fn, scheduler?: Function) {\n    this._fn = fn\n    this.scheduler = scheduler\n  }\n}\n\nfunction effect(fn) {\n  const eff = new reactiveEffect(fn)\n}\n```\n#### 3.new完后，我们需要让cb立马执行一次。可以发现，effect函数的形参fn被赋值给了reactiveEffect中的_fn，因此我们需要在reactiveEffect中写一个public方法，该方法执行this._fn()，我们把该方法叫做run：\n``` js\nclass reactiveEffect {\n  deps = [] // 收集依赖到该数组，因为依赖不一定只有一个(上面代码就user.age一个，因此这种情况deps.length = 1)\n  constructor(fn, scheduler?: Function) {\n    this._fn = fn\n    this.scheduler = scheduler\n  }\n  run() {\n    this._fn()\n  }\n}\n```\n然后在effect函数中调用：\n``` js\nfunction effect(fn) {\n  const eff = new reactiveEffect(fn)\n  eff.run()\n}\n```\n至此，effect的cb会立即执行一次。\n\n#### 4.收集/触发依赖；\n这里需要简单讲一下reactive。\n你首先肯定要写一个reactive函数，这个函数返回一个Proxy: \n``` js\nfunction reactive(raw) {\n  return new Proxy(raw, {\n    // todo: get and set\n  })\n}\n```\n那么这里最重要的就是todo里面的内容了。\n我们在实际使用时，比如`const person = reactive({ age: 1 })`，然后调用obj.age，此时就应该触发get，那么我们来实现get：\n``` js\nfunction createGetter() {\n  return function get(target, key) {\n    const res = Reflect.get(target, key)\n    // todo\n    // track(target, key)\n    return res\n  }\n}\n\nfunction reactive(raw) {\n  return new Proxy(raw, {\n    // todo: get and set\n    get: createGetter()\n  })\n}\n\n```\n此时调用obj.age，就会触发这个get，返回res给obj.age。但是呢为了实现响应性，让effect的cb被触发，我们需要实现这个track函数，该函数应该放在effect模块中实现，在reactive中引入effect模块的track函数：\n``` js\n// effect.ts\nlet activeEffect = null // 存reactiveEffect，此段代码先忽略，下面一段代码实现该变量\nconst targetMap = new Map() // 存target\nexport function track(target, key) {\n  // target->key->dep\n  // 1.存target\n  // 2.存key\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    depsMap = new Map() // 存key\n    targetMap.set(target, depsMap)\n  }\n  let dep = depsMap.get(key)\n  if (!dep) {\n    dep = new Set()\n    depsMap.set(key, dep)\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect)\n    activeEffect.deps.push(dep)\n  }\n}\n\n```\n可以发现里面有activeEffect，这是effect模块中的全局变量，在外层定义。在reactiveEffect的run函数中，我们对它进行赋值：\n``` js\nrun() {\nactiveEffect = this // 赋值\nconst result = this._fn()\nactiveEffect = undefined\nreturn result\n}\n```\n这段可能不太好理解，我来点通俗易懂的解释：\n执行this._fn()的时候，视角就应该跑去这个_fn的内部，如果这个_fn内部有Proxy.get/set被触发，就会track/trigger；\n而如若执行get导致执行track，那么track里面的activeEffect是被赋值给了this的，于是就会执行后面的dep.add(activeEffect)。可能你已经猜到了，这么做就是为了存储activeEffect到dep中，以便后续set的时候执行dep_item.run()，dep数组的每个item都是一个reactiveEffect实例，拥有run方法，因此dep_item.run()就会执行effect中的cb。\n那么来实现set：\n``` js\nfunction createSetter() {\n  return function set(target, key, value) {\n    const res = Reflect.set(target, key, value)\n    // todo\n    // trigger(target, key)\n    return res\n  }\n}\n\nfunction reactive(raw) {\n  return new Proxy(raw, {\n    // todo: get and set\n    get: createGetter(),\n    set: createSetter()\n  })\n}\n```\n相应的，我们来实现trigger，trigger会执行effect的cb：\n``` js\nexport function trigger(target, key) {\n  // 1.找到target\n  // 2.找到key\n  // 3.找到dep\n  // 4.执行dep\n  const depsMap = targetMap.get(target)\n  const dep = depsMap.get(key)\n  triggerEffects(dep)\n}\nexport function triggerEffects(dep) {\n  // 执行收集到的所有的 effect 的 run 方法\n  for (const effect of dep) {\n    effect.run()\n  }\n}\n```\n找到dep，然后执行所有dep的item(即effect)即可。\n\n用demo总结：\n对于这段代码：\n``` js\nconst user = reactive({ age: 19 })\nlet double\neffect(() => {\n  console.log(user.age, 'user.age')\n})\nuser.age = 20\n```\n我的理解：\n1.首先执行effect()这个函数\n2.eff.run()执行上面effect()括号内的callback，\n  此时currentEffect就被赋值给了这个callback，\n  后面set的时候再触发该callback，\n  相当于又执行了effect()括号内的callback\n 3.执行callback的时候发现user.age被访问(被proxy劫持，触发get)了，于是执行track()\n 4.执行track()的时候发现currentEffect存在，\n   于是dep.add，即把callback添加到dep中，用于后面的trigger执行该callback\n5. 执行user.age = 20的时候，触发set，于是执行trigger()\n6. 执行trigger()的时候，遍历dep，执行dep中的callback，即effect()括号内的callback，最终实现了类似vue的响应性\n\n------------------------------------\n完整代码：[https://github.com/co2color/easy-vue3/blob/main/src/reactivity/effect.ts](https://github.com/co2color/easy-vue3/blob/main/src/reactivity/effect.ts)\n"
}
